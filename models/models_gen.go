// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/shopspring/decimal"
)

type AccountResult struct {
	Account *Account `json:"account"`
}

type AccountsConnection struct {
	PageInfo *PageInfo                 `json:"pageInfo"`
	Edges    []*AccountsConnectionEdge `json:"edges"`
}

type AccountsConnectionEdge struct {
	Cursor string   `json:"cursor"`
	Node   *Account `json:"node"`
}

type AccountsFilter struct {
	UserIDs       []string    `json:"userIDs"`
	AvailableFrom *MoneyInput `json:"availableFrom"`
}

type ApproveUserFormInput struct {
	UserFormID string `json:"userFormId"`
}

type AuctionInput struct {
	AuctionID string `json:"auctionId"`
}

type AuctionResult struct {
	Auction *Auction `json:"auction"`
}

type AuctionsConnection struct {
	PageInfo *PageInfo                 `json:"pageInfo"`
	Edges    []*AuctionsConnectionEdge `json:"edges"`
}

type AuctionsConnectionEdge struct {
	Cursor string   `json:"cursor"`
	Node   *Auction `json:"node"`
}

type AuctionsFilter struct {
	IDs              []string       `json:"IDs"`
	States           []AuctionState `json:"states"`
	SellerIDs        []string       `json:"sellerIDs"`
	BuyerIDs         []string       `json:"buyerIDs"`
	ProductIDs       []string       `json:"productIDs"`
	StartedAt        *DateTimeRange `json:"startedAt"`
	ScheduledStartAt *DateTimeRange `json:"scheduledStartAt"`
}

type BankResult struct {
	Bank *Bank `json:"bank"`
}

type BanksConnection struct {
	PageInfo *PageInfo              `json:"pageInfo"`
	Edges    []*BanksConnectionEdge `json:"edges"`
}

type BanksConnectionEdge struct {
	Cursor string `json:"cursor"`
	Node   *Bank  `json:"node"`
}

type BanksFilter struct {
	IDs  []string `json:"IDs"`
	Name *string  `json:"name"`
}

type CreateAccountInput struct {
	NominalAccountID string `json:"nominalAccountID"`
}

type CreateBankInput struct {
	Name                 string `json:"name"`
	Bic                  string `json:"bic"`
	CorrespondentAccount string `json:"correspondentAccount"`
	Inn                  string `json:"inn"`
	Kpp                  string `json:"kpp"`
}

type CreateNominalAccountInput struct {
	Name          string `json:"name"`
	Receiver      string `json:"receiver"`
	AccountNumber string `json:"accountNumber"`
	BankID        string `json:"bankId"`
}

type CreateOfferInput struct {
	AuctionID string          `json:"auctionId"`
	AccountID string          `json:"accountId"`
	Amount    decimal.Decimal `json:"amount"`
}

type DateTimeRange struct {
	From *time.Time `json:"from"`
	To   *time.Time `json:"to"`
}

type DealStateFilter struct {
	CreatorIDs []string `json:"creatorIDs"`
	OfferIDs   []string `json:"offerIDs"`
}

type DeclineProductInput struct {
	ProductID     string  `json:"productId"`
	DeclainReason *string `json:"declainReason"`
}

type DeclineUserFormInput struct {
	UserFormID    string  `json:"userFormId"`
	DeclainReason *string `json:"declainReason"`
}

type LoginInput struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// Input money in a specific currency
type MoneyInput struct {
	Amount   decimal.Decimal `json:"amount"`
	Currency CurrencyEnum    `json:"currency"`
}

type NominalAccountResult struct {
	NominalAccount *NominalAccount `json:"nominalAccount"`
}

type NominalAccountsConnection struct {
	PageInfo *PageInfo                        `json:"pageInfo"`
	Edges    []*NominalAccountsConnectionEdge `json:"edges"`
}

type NominalAccountsConnectionEdge struct {
	Cursor string          `json:"cursor"`
	Node   *NominalAccount `json:"node"`
}

type NominalAccountsFilter struct {
	IDs     []string `json:"IDs"`
	Name    *string  `json:"name"`
	BankIDs []string `json:"bankIDs"`
}

type OfferProductResult struct {
	Product *Product `json:"product"`
}

type OfferResult struct {
	Offer *Offer `json:"offer"`
}

type OffersConnection struct {
	PageInfo *PageInfo               `json:"pageInfo"`
	Edges    []*OffersConnectionEdge `json:"edges"`
}

type OffersConnectionEdge struct {
	Cursor string `json:"cursor"`
	Node   *Offer `json:"node"`
}

type OffersFilter struct {
	IDs        []string     `json:"IDs"`
	States     []OfferState `json:"states"`
	UserIDs    []string     `json:"userIDs"`
	AuctionIDs []string     `json:"auctionIDs"`
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor"`
	EndCursor       *string `json:"endCursor"`
}

type ProductInput struct {
	ProductID string `json:"productId"`
}

type ProductResult struct {
	Product *Product `json:"product"`
}

type ProductsConnection struct {
	PageInfo *PageInfo                 `json:"pageInfo"`
	Edges    []*ProductsConnectionEdge `json:"edges"`
}

type ProductsConnectionEdge struct {
	Cursor string   `json:"cursor"`
	Node   *Product `json:"node"`
}

type ProductsFilter struct {
	State    []ProductState `json:"state"`
	OwnerIDs []string       `json:"ownerIDs"`
}

type RequestSetUserEmailInput struct {
	Email string `json:"email"`
}

type RequestSetUserPhoneInput struct {
	Phone string `json:"phone"`
}

type SellProductResult struct {
	Product *Product `json:"product"`
}

type TakeOffProductResult struct {
	Product *Product `json:"product"`
}

// Used for actions activation
type TokenInput struct {
	Token string `json:"token"`
}

// Used for login and registration
type TokenResult struct {
	Token string `json:"token"`
}

type TransactionsConnection struct {
	PageInfo *PageInfo                     `json:"pageInfo"`
	Edges    []*TransactionsConnectionEdge `json:"edges"`
}

type TransactionsConnectionEdge struct {
	Cursor string       `json:"cursor"`
	Node   *Transaction `json:"node"`
}

type TransactionsFilter struct {
	IDs            []string           `json:"IDs"`
	DateRange      *DateTimeRange     `json:"dateRange"`
	States         []TransactionState `json:"states"`
	Types          []TransactionType  `json:"types"`
	Currencies     []CurrencyEnum     `json:"currencies"`
	AccountFormIDs []string           `json:"accountFormIDs"`
	AccountToIDs   []string           `json:"accountToIDs"`
	OfferIDs       []string           `json:"offerIDs"`
	AuctionIDs     []string           `json:"auctionIDs"`
	// Account in from or to field
	AccountIDs []string `json:"accountIDs"`
}

type UpdateAuctionInput struct {
	AuctionID         string           `json:"auctionId"`
	Currency          CurrencyEnum     `json:"currency"`
	SellerAccountID   *string          `json:"sellerAccountId"`
	MinAmount         *decimal.Decimal `json:"minAmount"`
	ScheduledStartAt  *time.Time       `json:"scheduledStartAt"`
	ScheduledFinishAt *time.Time       `json:"scheduledFinishAt"`
}

type UpdateBankInput struct {
	BankID               string `json:"bankId"`
	Name                 string `json:"name"`
	Bic                  string `json:"bic"`
	CorrespondentAccount string `json:"correspondentAccount"`
	Inn                  string `json:"inn"`
	Kpp                  string `json:"kpp"`
}

type UpdateNominalAccountInput struct {
	AccountID     string `json:"accountId"`
	Name          string `json:"name"`
	Receiver      string `json:"receiver"`
	AccountNumber string `json:"accountNumber"`
	BankID        string `json:"bankId"`
}

type UpdateProductInput struct {
	ProductID   string `json:"productId"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

type UpdateUserDraftFormInput struct {
	Name     *string       `json:"name"`
	Currency *CurrencyEnum `json:"currency"`
}

type UpdateUserPasswordInput struct {
	OldPassword *string `json:"oldPassword"`
	Password    string  `json:"password"`
}

type UserFormHistoryFilter struct {
	State []UserFormState `json:"state"`
	ID    []string        `json:"id"`
}

type UserFormResult struct {
	UserForm *UserForm `json:"userForm"`
}

type UserFormsConnection struct {
	PageInfo *PageInfo                  `json:"pageInfo"`
	Edges    []*UserFormsConnectionEdge `json:"edges"`
}

type UserFormsConnectionEdge struct {
	Cursor string    `json:"cursor"`
	Node   *UserForm `json:"node"`
}

type UserFormsFilter struct {
	State  []UserFormState `json:"state"`
	ID     []string        `json:"id"`
	UserID []string        `json:"userId"`
}

type UserResult struct {
	User *User `json:"user"`
}

type UsersConnection struct {
	PageInfo *PageInfo              `json:"pageInfo"`
	Edges    []*UsersConnectionEdge `json:"edges"`
}

type UsersConnectionEdge struct {
	Cursor string `json:"cursor"`
	Node   *User  `json:"node"`
}

type UsersFilter struct {
	ID []string `json:"id"`
}

type AuctionState string

const (
	AuctionStateCreated   AuctionState = "CREATED"
	AuctionStateStarted   AuctionState = "STARTED"
	AuctionStateFinished  AuctionState = "FINISHED"
	AuctionStateFailed    AuctionState = "FAILED"
	AuctionStateSucceeded AuctionState = "SUCCEEDED"
)

var AllAuctionState = []AuctionState{
	AuctionStateCreated,
	AuctionStateStarted,
	AuctionStateFinished,
	AuctionStateFailed,
	AuctionStateSucceeded,
}

func (e AuctionState) IsValid() bool {
	switch e {
	case AuctionStateCreated, AuctionStateStarted, AuctionStateFinished, AuctionStateFailed, AuctionStateSucceeded:
		return true
	}
	return false
}

func (e AuctionState) String() string {
	return string(e)
}

func (e *AuctionState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuctionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuctionState", str)
	}
	return nil
}

func (e AuctionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CurrencyEnum string

const (
	CurrencyEnumRub CurrencyEnum = "RUB"
	CurrencyEnumEur CurrencyEnum = "EUR"
	CurrencyEnumUsd CurrencyEnum = "USD"
)

var AllCurrencyEnum = []CurrencyEnum{
	CurrencyEnumRub,
	CurrencyEnumEur,
	CurrencyEnumUsd,
}

func (e CurrencyEnum) IsValid() bool {
	switch e {
	case CurrencyEnumRub, CurrencyEnumEur, CurrencyEnumUsd:
		return true
	}
	return false
}

func (e CurrencyEnum) String() string {
	return string(e)
}

func (e *CurrencyEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CurrencyEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CurrencyEnum", str)
	}
	return nil
}

func (e CurrencyEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type DealStateEnum string

const (
	DealStateEnumTransferringMoney     DealStateEnum = "TRANSFERRING_MONEY"
	DealStateEnumTransferMoneyFailed   DealStateEnum = "TRANSFER_MONEY_FAILED"
	DealStateEnumTransferringProduct   DealStateEnum = "TRANSFERRING_PRODUCT"
	DealStateEnumTransferProductFailed DealStateEnum = "TRANSFER_PRODUCT_FAILED"
	DealStateEnumSucceeded             DealStateEnum = "SUCCEEDED"
	DealStateEnumReturningMoney        DealStateEnum = "RETURNING_MONEY"
	DealStateEnumReturnMoneyFailed     DealStateEnum = "RETURN_MONEY_FAILED"
	DealStateEnumMoneyReturned         DealStateEnum = "MONEY_RETURNED"
)

var AllDealStateEnum = []DealStateEnum{
	DealStateEnumTransferringMoney,
	DealStateEnumTransferMoneyFailed,
	DealStateEnumTransferringProduct,
	DealStateEnumTransferProductFailed,
	DealStateEnumSucceeded,
	DealStateEnumReturningMoney,
	DealStateEnumReturnMoneyFailed,
	DealStateEnumMoneyReturned,
}

func (e DealStateEnum) IsValid() bool {
	switch e {
	case DealStateEnumTransferringMoney, DealStateEnumTransferMoneyFailed, DealStateEnumTransferringProduct, DealStateEnumTransferProductFailed, DealStateEnumSucceeded, DealStateEnumReturningMoney, DealStateEnumReturnMoneyFailed, DealStateEnumMoneyReturned:
		return true
	}
	return false
}

func (e DealStateEnum) String() string {
	return string(e)
}

func (e *DealStateEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = DealStateEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid DealStateEnum", str)
	}
	return nil
}

func (e DealStateEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OfferState string

const (
	OfferStateCreated   OfferState = "CREATED"
	OfferStateCancelled OfferState = "CANCELLED"
	OfferStateAccepted  OfferState = "ACCEPTED"
	OfferStateSucceeded OfferState = "SUCCEEDED"
	OfferStateFailed    OfferState = "FAILED"
)

var AllOfferState = []OfferState{
	OfferStateCreated,
	OfferStateCancelled,
	OfferStateAccepted,
	OfferStateSucceeded,
	OfferStateFailed,
}

func (e OfferState) IsValid() bool {
	switch e {
	case OfferStateCreated, OfferStateCancelled, OfferStateAccepted, OfferStateSucceeded, OfferStateFailed:
		return true
	}
	return false
}

func (e OfferState) String() string {
	return string(e)
}

func (e *OfferState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OfferState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OfferState", str)
	}
	return nil
}

func (e OfferState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductState string

const (
	ProductStateCreated    ProductState = "CREATED"
	ProductStateModerating ProductState = "MODERATING"
	ProductStateApproved   ProductState = "APPROVED"
	ProductStateDeclained  ProductState = "DECLAINED"
)

var AllProductState = []ProductState{
	ProductStateCreated,
	ProductStateModerating,
	ProductStateApproved,
	ProductStateDeclained,
}

func (e ProductState) IsValid() bool {
	switch e {
	case ProductStateCreated, ProductStateModerating, ProductStateApproved, ProductStateDeclained:
		return true
	}
	return false
}

func (e ProductState) String() string {
	return string(e)
}

func (e *ProductState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductState", str)
	}
	return nil
}

func (e ProductState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleEnum string

const (
	RoleEnumUser    RoleEnum = "USER"
	RoleEnumOwner   RoleEnum = "OWNER"
	RoleEnumManager RoleEnum = "MANAGER"
	RoleEnumAdmin   RoleEnum = "ADMIN"
)

var AllRoleEnum = []RoleEnum{
	RoleEnumUser,
	RoleEnumOwner,
	RoleEnumManager,
	RoleEnumAdmin,
}

func (e RoleEnum) IsValid() bool {
	switch e {
	case RoleEnumUser, RoleEnumOwner, RoleEnumManager, RoleEnumAdmin:
		return true
	}
	return false
}

func (e RoleEnum) String() string {
	return string(e)
}

func (e *RoleEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleEnum", str)
	}
	return nil
}

func (e RoleEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionState string

const (
	TransactionStateCreated    TransactionState = "CREATED"
	TransactionStateCancelled  TransactionState = "CANCELLED"
	TransactionStateProcessing TransactionState = "PROCESSING"
	TransactionStateNew        TransactionState = "NEW"
	TransactionStateError      TransactionState = "ERROR"
	TransactionStateSucceeded  TransactionState = "SUCCEEDED"
	TransactionStateFailed     TransactionState = "FAILED"
)

var AllTransactionState = []TransactionState{
	TransactionStateCreated,
	TransactionStateCancelled,
	TransactionStateProcessing,
	TransactionStateNew,
	TransactionStateError,
	TransactionStateSucceeded,
	TransactionStateFailed,
}

func (e TransactionState) IsValid() bool {
	switch e {
	case TransactionStateCreated, TransactionStateCancelled, TransactionStateProcessing, TransactionStateNew, TransactionStateError, TransactionStateSucceeded, TransactionStateFailed:
		return true
	}
	return false
}

func (e TransactionState) String() string {
	return string(e)
}

func (e *TransactionState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionState", str)
	}
	return nil
}

func (e TransactionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionType string

const (
	TransactionTypeDeposit            TransactionType = "DEPOSIT"
	TransactionTypeCurrencyConvertion TransactionType = "CURRENCY_CONVERTION"
	TransactionTypeReturn             TransactionType = "RETURN"
	TransactionTypeFeeReturn          TransactionType = "FEE_RETURN"
	TransactionTypeBuy                TransactionType = "BUY"
	TransactionTypeFeeBuy             TransactionType = "FEE_BUY"
	TransactionTypeWithdrawal         TransactionType = "WITHDRAWAL"
	TransactionTypeFeeWithdrawal      TransactionType = "FEE_WITHDRAWAL"
)

var AllTransactionType = []TransactionType{
	TransactionTypeDeposit,
	TransactionTypeCurrencyConvertion,
	TransactionTypeReturn,
	TransactionTypeFeeReturn,
	TransactionTypeBuy,
	TransactionTypeFeeBuy,
	TransactionTypeWithdrawal,
	TransactionTypeFeeWithdrawal,
}

func (e TransactionType) IsValid() bool {
	switch e {
	case TransactionTypeDeposit, TransactionTypeCurrencyConvertion, TransactionTypeReturn, TransactionTypeFeeReturn, TransactionTypeBuy, TransactionTypeFeeBuy, TransactionTypeWithdrawal, TransactionTypeFeeWithdrawal:
		return true
	}
	return false
}

func (e TransactionType) String() string {
	return string(e)
}

func (e *TransactionType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionType", str)
	}
	return nil
}

func (e TransactionType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserFormState string

const (
	UserFormStateCreated    UserFormState = "CREATED"
	UserFormStateModerating UserFormState = "MODERATING"
	UserFormStateApproved   UserFormState = "APPROVED"
	UserFormStateDeclained  UserFormState = "DECLAINED"
)

var AllUserFormState = []UserFormState{
	UserFormStateCreated,
	UserFormStateModerating,
	UserFormStateApproved,
	UserFormStateDeclained,
}

func (e UserFormState) IsValid() bool {
	switch e {
	case UserFormStateCreated, UserFormStateModerating, UserFormStateApproved, UserFormStateDeclained:
		return true
	}
	return false
}

func (e UserFormState) String() string {
	return string(e)
}

func (e *UserFormState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserFormState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserFormState", str)
	}
	return nil
}

func (e UserFormState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
