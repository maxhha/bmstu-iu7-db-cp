// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package models

import (
	"fmt"
	"io"
	"strconv"
	"time"

	"github.com/shopspring/decimal"
)

type AccountsConnection struct {
	PageInfo *PageInfo                 `json:"pageInfo"`
	Edges    []*AccountsConnectionEdge `json:"edges"`
}

type AccountsConnectionEdge struct {
	Cursor string           `json:"cursor"`
	Node   AccountInterface `json:"node"`
}

type ApproveUserFormInput struct {
	UserFormID string `json:"userFormId"`
}

type AuctionInput struct {
	AuctionID string `json:"auctionId"`
}

type AuctionResult struct {
	Auction *Auction `json:"auction"`
}

type AuctionsConnection struct {
	PageInfo *PageInfo                 `json:"pageInfo"`
	Edges    []*AuctionsConnectionEdge `json:"edges"`
}

type AuctionsConnectionEdge struct {
	Cursor string   `json:"cursor"`
	Node   *Auction `json:"node"`
}

type AuctionsFilter struct {
	IDs        []string       `json:"IDs"`
	States     []AuctionState `json:"states"`
	SellerIDs  []string       `json:"sellerIDs"`
	BuyerIDs   []string       `json:"buyerIDs"`
	ProductIDs []string       `json:"productIDs"`
}

type CreateOfferInput struct {
	ProductID string          `json:"productId"`
	Amount    decimal.Decimal `json:"amount"`
}

type CreateOfferResult struct {
	Offer *Offer `json:"offer"`
}

type DateTimeRange struct {
	From *time.Time `json:"from"`
	To   *time.Time `json:"to"`
}

type DeclineProductInput struct {
	ProductID     string  `json:"productId"`
	DeclainReason *string `json:"declainReason"`
}

type DeclineUserFormInput struct {
	UserFormID    string  `json:"userFormId"`
	DeclainReason *string `json:"declainReason"`
}

type LoginInput struct {
	Username string `json:"username"`
	Password string `json:"password"`
}

// Input money in a specific currency
type MoneyInput struct {
	Amount   decimal.Decimal `json:"amount"`
	Currency CurrencyEnum    `json:"currency"`
}

type OfferProductResult struct {
	Product *Product `json:"product"`
}

type OffersConnection struct {
	PageInfo *PageInfo               `json:"pageInfo"`
	Edges    []*OffersConnectionEdge `json:"edges"`
}

type OffersConnectionEdge struct {
	Cursor string `json:"cursor"`
	Node   *Offer `json:"node"`
}

type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *string `json:"startCursor"`
	EndCursor       *string `json:"endCursor"`
}

type ProductInput struct {
	ProductID string `json:"productId"`
}

type ProductResult struct {
	Product *Product `json:"product"`
}

type ProductsConnection struct {
	PageInfo *PageInfo                 `json:"pageInfo"`
	Edges    []*ProductsConnectionEdge `json:"edges"`
}

type ProductsConnectionEdge struct {
	Cursor string   `json:"cursor"`
	Node   *Product `json:"node"`
}

type ProductsFilter struct {
	OwnerIDs []string `json:"ownerIDs"`
}

type RemoveOfferInput struct {
	OfferID string `json:"offerId"`
}

type RemoveOfferResult struct {
	Status string `json:"status"`
}

type RequestSetUserEmailInput struct {
	Email string `json:"email"`
}

type RequestSetUserPhoneInput struct {
	Phone string `json:"phone"`
}

type SellProductResult struct {
	Product *Product `json:"product"`
}

type TakeOffProductResult struct {
	Product *Product `json:"product"`
}

// Used for actions activation
type TokenInput struct {
	Token string `json:"token"`
}

// Used for login and registration
type TokenResult struct {
	Token string `json:"token"`
}

type TransactionsConnection struct {
	PageInfo *PageInfo                     `json:"pageInfo"`
	Edges    []*TransactionsConnectionEdge `json:"edges"`
}

type TransactionsConnectionEdge struct {
	Cursor string       `json:"cursor"`
	Node   *Transaction `json:"node"`
}

type UpdateAuctionInput struct {
	AuctionID         string           `json:"auctionId"`
	Currency          CurrencyEnum     `json:"currency"`
	MinAmount         *decimal.Decimal `json:"minAmount"`
	ScheduledStartAt  *time.Time       `json:"scheduledStartAt"`
	ScheduledFinishAt *time.Time       `json:"scheduledFinishAt"`
}

type UpdateProductInput struct {
	ProductID   string `json:"productId"`
	Title       string `json:"title"`
	Description string `json:"description"`
}

type UpdateUserDraftFormInput struct {
	Name     *string       `json:"name"`
	Currency *CurrencyEnum `json:"currency"`
}

type UpdateUserPasswordInput struct {
	OldPassword *string `json:"oldPassword"`
	Password    string  `json:"password"`
}

type UserAccountsConnection struct {
	PageInfo *PageInfo                     `json:"pageInfo"`
	Edges    []*UserAccountsConnectionEdge `json:"edges"`
}

// Connection with UserAccount only
type UserAccountsConnectionEdge struct {
	Cursor string       `json:"cursor"`
	Node   *UserAccount `json:"node"`
}

// UserFrom with all required fields filled in
type UserFormFilled struct {
	// User email
	Email string `json:"email"`
	// User phone
	Phone string `json:"phone"`
	// User name
	Name string `json:"name"`
	// User default currency
	Currency CurrencyEnum `json:"currency"`
}

type UserFormHistoryFilter struct {
	State []UserFormState `json:"state"`
	ID    []string        `json:"id"`
}

type UserFormResult struct {
	UserForm *UserForm `json:"userForm"`
}

type UserFormsConnection struct {
	PageInfo *PageInfo                  `json:"pageInfo"`
	Edges    []*UserFormsConnectionEdge `json:"edges"`
}

type UserFormsConnectionEdge struct {
	Cursor string    `json:"cursor"`
	Node   *UserForm `json:"node"`
}

type UserFormsFilter struct {
	State  []UserFormState `json:"state"`
	ID     []string        `json:"id"`
	UserID []string        `json:"userId"`
}

type UserResult struct {
	User *User `json:"user"`
}

type UsersConnection struct {
	PageInfo *PageInfo              `json:"pageInfo"`
	Edges    []*UsersConnectionEdge `json:"edges"`
}

type UsersConnectionEdge struct {
	Cursor string `json:"cursor"`
	Node   *User  `json:"node"`
}

type UsersFilter struct {
	ID []string `json:"id"`
}

type AuctionState string

const (
	AuctionStateCreated   AuctionState = "CREATED"
	AuctionStateStarted   AuctionState = "STARTED"
	AuctionStateFinished  AuctionState = "FINISHED"
	AuctionStateFailed    AuctionState = "FAILED"
	AuctionStateSucceeded AuctionState = "SUCCEEDED"
)

var AllAuctionState = []AuctionState{
	AuctionStateCreated,
	AuctionStateStarted,
	AuctionStateFinished,
	AuctionStateFailed,
	AuctionStateSucceeded,
}

func (e AuctionState) IsValid() bool {
	switch e {
	case AuctionStateCreated, AuctionStateStarted, AuctionStateFinished, AuctionStateFailed, AuctionStateSucceeded:
		return true
	}
	return false
}

func (e AuctionState) String() string {
	return string(e)
}

func (e *AuctionState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = AuctionState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid AuctionState", str)
	}
	return nil
}

func (e AuctionState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type CurrencyEnum string

const (
	CurrencyEnumRub CurrencyEnum = "RUB"
	CurrencyEnumEur CurrencyEnum = "EUR"
	CurrencyEnumUsd CurrencyEnum = "USD"
)

var AllCurrencyEnum = []CurrencyEnum{
	CurrencyEnumRub,
	CurrencyEnumEur,
	CurrencyEnumUsd,
}

func (e CurrencyEnum) IsValid() bool {
	switch e {
	case CurrencyEnumRub, CurrencyEnumEur, CurrencyEnumUsd:
		return true
	}
	return false
}

func (e CurrencyEnum) String() string {
	return string(e)
}

func (e *CurrencyEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = CurrencyEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid CurrencyEnum", str)
	}
	return nil
}

func (e CurrencyEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type OfferStateEnum string

const (
	OfferStateEnumCreated               OfferStateEnum = "CREATED"
	OfferStateEnumCancelled             OfferStateEnum = "CANCELLED"
	OfferStateEnumTransferringMoney     OfferStateEnum = "TRANSFERRING_MONEY"
	OfferStateEnumTransferMoneyFailed   OfferStateEnum = "TRANSFER_MONEY_FAILED"
	OfferStateEnumTransferringProduct   OfferStateEnum = "TRANSFERRING_PRODUCT"
	OfferStateEnumTransferProductFailed OfferStateEnum = "TRANSFER_PRODUCT_FAILED"
	OfferStateEnumSucceeded             OfferStateEnum = "SUCCEEDED"
	OfferStateEnumReturningMoney        OfferStateEnum = "RETURNING_MONEY"
	OfferStateEnumReturnMoneyFailed     OfferStateEnum = "RETURN_MONEY_FAILED"
	OfferStateEnumMoneyReturned         OfferStateEnum = "MONEY_RETURNED"
)

var AllOfferStateEnum = []OfferStateEnum{
	OfferStateEnumCreated,
	OfferStateEnumCancelled,
	OfferStateEnumTransferringMoney,
	OfferStateEnumTransferMoneyFailed,
	OfferStateEnumTransferringProduct,
	OfferStateEnumTransferProductFailed,
	OfferStateEnumSucceeded,
	OfferStateEnumReturningMoney,
	OfferStateEnumReturnMoneyFailed,
	OfferStateEnumMoneyReturned,
}

func (e OfferStateEnum) IsValid() bool {
	switch e {
	case OfferStateEnumCreated, OfferStateEnumCancelled, OfferStateEnumTransferringMoney, OfferStateEnumTransferMoneyFailed, OfferStateEnumTransferringProduct, OfferStateEnumTransferProductFailed, OfferStateEnumSucceeded, OfferStateEnumReturningMoney, OfferStateEnumReturnMoneyFailed, OfferStateEnumMoneyReturned:
		return true
	}
	return false
}

func (e OfferStateEnum) String() string {
	return string(e)
}

func (e *OfferStateEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = OfferStateEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid OfferStateEnum", str)
	}
	return nil
}

func (e OfferStateEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type ProductState string

const (
	ProductStateCreated    ProductState = "CREATED"
	ProductStateModerating ProductState = "MODERATING"
	ProductStateApproved   ProductState = "APPROVED"
	ProductStateDeclained  ProductState = "DECLAINED"
)

var AllProductState = []ProductState{
	ProductStateCreated,
	ProductStateModerating,
	ProductStateApproved,
	ProductStateDeclained,
}

func (e ProductState) IsValid() bool {
	switch e {
	case ProductStateCreated, ProductStateModerating, ProductStateApproved, ProductStateDeclained:
		return true
	}
	return false
}

func (e ProductState) String() string {
	return string(e)
}

func (e *ProductState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = ProductState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid ProductState", str)
	}
	return nil
}

func (e ProductState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type RoleType string

const (
	RoleTypeAdmin   RoleType = "ADMIN"
	RoleTypeManager RoleType = "MANAGER"
)

var AllRoleType = []RoleType{
	RoleTypeAdmin,
	RoleTypeManager,
}

func (e RoleType) IsValid() bool {
	switch e {
	case RoleTypeAdmin, RoleTypeManager:
		return true
	}
	return false
}

func (e RoleType) String() string {
	return string(e)
}

func (e *RoleType) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = RoleType(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid RoleType", str)
	}
	return nil
}

func (e RoleType) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionStateEnum string

const (
	TransactionStateEnumCreated    TransactionStateEnum = "CREATED"
	TransactionStateEnumCancelled  TransactionStateEnum = "CANCELLED"
	TransactionStateEnumProcessing TransactionStateEnum = "PROCESSING"
	TransactionStateEnumError      TransactionStateEnum = "ERROR"
	TransactionStateEnumSucceeded  TransactionStateEnum = "SUCCEEDED"
	TransactionStateEnumFailed     TransactionStateEnum = "FAILED"
)

var AllTransactionStateEnum = []TransactionStateEnum{
	TransactionStateEnumCreated,
	TransactionStateEnumCancelled,
	TransactionStateEnumProcessing,
	TransactionStateEnumError,
	TransactionStateEnumSucceeded,
	TransactionStateEnumFailed,
}

func (e TransactionStateEnum) IsValid() bool {
	switch e {
	case TransactionStateEnumCreated, TransactionStateEnumCancelled, TransactionStateEnumProcessing, TransactionStateEnumError, TransactionStateEnumSucceeded, TransactionStateEnumFailed:
		return true
	}
	return false
}

func (e TransactionStateEnum) String() string {
	return string(e)
}

func (e *TransactionStateEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionStateEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionStateEnum", str)
	}
	return nil
}

func (e TransactionStateEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type TransactionTypeEnum string

const (
	TransactionTypeEnumDeposit    TransactionTypeEnum = "DEPOSIT"
	TransactionTypeEnumBuy        TransactionTypeEnum = "BUY"
	TransactionTypeEnumFee        TransactionTypeEnum = "FEE"
	TransactionTypeEnumWithdrawal TransactionTypeEnum = "WITHDRAWAL"
)

var AllTransactionTypeEnum = []TransactionTypeEnum{
	TransactionTypeEnumDeposit,
	TransactionTypeEnumBuy,
	TransactionTypeEnumFee,
	TransactionTypeEnumWithdrawal,
}

func (e TransactionTypeEnum) IsValid() bool {
	switch e {
	case TransactionTypeEnumDeposit, TransactionTypeEnumBuy, TransactionTypeEnumFee, TransactionTypeEnumWithdrawal:
		return true
	}
	return false
}

func (e TransactionTypeEnum) String() string {
	return string(e)
}

func (e *TransactionTypeEnum) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = TransactionTypeEnum(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid TransactionTypeEnum", str)
	}
	return nil
}

func (e TransactionTypeEnum) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}

type UserFormState string

const (
	UserFormStateCreated    UserFormState = "CREATED"
	UserFormStateModerating UserFormState = "MODERATING"
	UserFormStateApproved   UserFormState = "APPROVED"
	UserFormStateDeclained  UserFormState = "DECLAINED"
)

var AllUserFormState = []UserFormState{
	UserFormStateCreated,
	UserFormStateModerating,
	UserFormStateApproved,
	UserFormStateDeclained,
}

func (e UserFormState) IsValid() bool {
	switch e {
	case UserFormStateCreated, UserFormStateModerating, UserFormStateApproved, UserFormStateDeclained:
		return true
	}
	return false
}

func (e UserFormState) String() string {
	return string(e)
}

func (e *UserFormState) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("enums must be strings")
	}

	*e = UserFormState(str)
	if !e.IsValid() {
		return fmt.Errorf("%s is not a valid UserFormState", str)
	}
	return nil
}

func (e UserFormState) MarshalGQL(w io.Writer) {
	fmt.Fprint(w, strconv.Quote(e.String()))
}
